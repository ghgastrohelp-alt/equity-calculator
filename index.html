<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Poker Equity — Desktop</title>
<style>
:root{
  --card-w:40px;
  --card-h:40px;
  --gap:2px;
  --bg:#071021;
  --panel:#0f1725;
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#061021,#071428);color:#e6eef8;display:flex;justify-content:center;align-items:center;height:100vh;}
.container{max-width:1000px;width:100%;}
h1{font-size:22px;margin:0 0 12px;text-align:center;}
.topPanel{display:flex;flex-direction:column;gap:8px;margin-bottom:12px;}
.resultPanel{background:linear-gradient(180deg,#031821,#081927);padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:6px;}
.resultBig{font-weight:800;font-size:18px;}
.muted{font-size:12px;color:#9fb3d6;}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
select,input[type=range]{padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:#0b2130;color:#e6eef8;}
.deckPanel {
  background: linear-gradient(90deg,#071226,#071728);
  padding: 8px;
  border-radius: 10px;
  margin: 10px auto;       /* centra il container orizzontalmente */
  display: flex;           
  justify-content: center;  /* centra le carte al suo interno */
}

.deck{display:grid;grid-template-columns:repeat(13,var(--card-w));gap:4px;justify-content:center;}
.card{width:var(--card-w);height:var(--card-h);border-radius:8px;background:#fff;display:flex;justify-content:center;align-items:center;font-weight:800;cursor:pointer;border:1px solid rgba(0,0,0,0.12);user-select:none;font-size:16px;}
.card.red{color:#b71c1c;}
.card.black{color:#0a1722;}
.card.used{opacity:0.3;}
.areas{display:flex;gap:12px;margin-top:10px;flex-direction:row;justify-content:center;flex-wrap:wrap;}
.panel {
  background: linear-gradient(180deg,#071827,#061528);
  padding: 8px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.03);
  flex: 0 0 auto;       /* non si espande per riempire lo spazio */
  max-width: 120px;     /* larghezza massima dei pannelli */
  display: flex;
  flex-direction: column;
  align-items: center;
}

.field{display:flex;gap:4px;align-items:center;min-height:var(--card-h);padding:4px;flex-wrap:nowrap;overflow:auto;}
.slot{width:var(--card-w);height:var(--card-h);border-radius:6px;background:transparent;border:1px dashed rgba(255,255,255,0.05);display:flex;justify-content:center;align-items:center;color:#e6eef8;font-weight:700;font-size:16px;min-width:var(--card-w);}
.slot.filled{background:#fff;color:#111;border-style:solid;}
.label{font-size:13px;color:#9fb3d6;margin-bottom:4px;text-align:center;}
.small{font-size:12px;color:#9fb3d6;}
.btn{padding:8px;border-radius:8px;border:none;background:#1f8fff;color:white;cursor:pointer;font-weight:700;}
.btn.green{background:#22c55e;}
footer{margin-top:10px;font-size:12px;color:#9fb3d6;text-align:center;}
</style>
</head>
<body>
<div class="container">
  <h1>Poker Equity — Desktop</h1>

  <div class="topPanel">
    <div class="resultPanel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div class="small">Giocatori al tavolo</div>
          <select id="players">
            <option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option>
          </select>
        </div>
        <div style="text-align:right">
          <div class="small">Trials Monte Carlo</div>
          <input id="trials" type="range" min="200" max="8000" step="200" value="2000" style="width:140px">
          <div class="small muted" id="trialsLabel">2000</div>
        </div>
      </div>
      <div class="resultBig" id="output">Equity: —</div>
      <div class="small muted" id="subOutput">Inserisci le 2 carte del giocatore (Hero) per calcolare.</div>
    </div>

    <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
      <label class="small">Piattaforma:</label>
      <select id="platformSelect">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
      </select>
      <button class="btn" id="reset">Reset &amp; Save</button>
      <button class="btn" id="export">Esporta piattaforma</button>
    </div>
  </div>


  <div class="deckPanel panel">
    <div class="label">Mazzo (clicca per copiare la carta negli slot)</div>
    <div id="deck" class="deck"></div>
  </div>

  <div class="areas">
    <div class="panel">
      <div class="label">Hero</div>
      <div id="hero" class="field"></div>
    </div>

    <div class="panel">
      <div class="label">Flop</div>
      <div id="flop" class="field"></div>
    </div>

    <div class="panel">
      <div class="label">Turn</div>
      <div id="turn" class="field"></div>
    </div>

    <div class="panel">
      <div class="label">River</div>
      <div id="river" class="field"></div>
    </div>

    <div class="panel">
      <div class="label">Villain</div>
      <div id="villain" class="field"></div>
    </div>
  </div>
</div>








<script>
const R = "A23456789TJQK";
const SUITS = ["s","h","c","d"];
const SUIT_CH = {c:"♣",d:"♦",h:"♥",s:"♠"};
let renderDeckArray = [];
const sequence = [
  {id:"hero", pos:0},{id:"hero", pos:1},
  {id:"flop", pos:0},{id:"flop", pos:1},{id:"flop", pos:2},
  {id:"turn", pos:0},{id:"river", pos:0},
  {id:"villain", pos:0},{id:"villain", pos:1}
];
const usedCards = new Set();

function buildOrderedDeck(){
  renderDeckArray = [];
  for(let s of SUITS) for(let r of R) renderDeckArray.push(r+s);
}

function renderDeck(usedSet=new Set()){
  const deckEl = document.getElementById("deck");
  deckEl.innerHTML = "";
  for(let c of renderDeckArray){
    const el = document.createElement("div");
    el.className = (c[1]==='h'||c[1]==='d')?"card red":"card black";
    if(usedSet.has(c)) el.classList.add('used');
    el.dataset.card = c;
    el.textContent = c[0]+SUIT_CH[c[1]];
    el.onclick = ()=>placeCardCopy(c);
    deckEl.appendChild(el);
  }
}

function initFields(){
  ["hero","flop","turn","river","villain"].forEach(id=>{
    const container = document.getElementById(id);
    container.innerHTML = "";
    let max = (id==="hero")?2:(id==="flop")?3:(id==="villain")?2:1;
    for(let i=0;i<max;i++){
      const s = document.createElement("div");
      s.className = "slot";
      s.dataset.container = id;
      s.dataset.pos = i;
      s.onclick = ()=>onSlotClick(s);
      container.appendChild(s);
    }
  });
}

function nextFreeSlotIndex(){
  for(let i=0;i<sequence.length;i++){
    const info = sequence[i];
    const slot = document.querySelector(`#${info.id} .slot[data-pos='${info.pos}']`);
    if(slot && !slot.dataset.card) return i;
  }
  return -1;
}

function placeCardCopy(card){
  const allSlots = [...document.querySelectorAll('.slot')];
  const existingSlot = allSlots.find(s => s.dataset.card === card);
  if(existingSlot){
    delete existingSlot.dataset.card;
    existingSlot.textContent = '';
    existingSlot.classList.remove('filled');
    const other = allSlots.map(s=>s.dataset.card).filter(Boolean);
    if(!other.includes(card)) usedCards.delete(card);
    renderDeck(usedCards);
    scheduleCalc();
    return;
  }
  const idx = nextFreeSlotIndex();
  if(idx===-1) return;
  const info = sequence[idx];
  const slot = document.querySelector(`#${info.id} .slot[data-pos='${info.pos}']`);
  slot.classList.add('filled');
  slot.textContent = card[0] + SUIT_CH[card[1]];
  slot.dataset.card = card;
  usedCards.add(card);
  renderDeck(usedCards);
  scheduleCalc();
}

function onSlotClick(slotEl){
  if(!slotEl.dataset.card) return;
  const removed = slotEl.dataset.card;
  delete slotEl.dataset.card;
  slotEl.textContent = '';
  slotEl.classList.remove('filled');
  const other = [...document.querySelectorAll('.slot')].map(s=>s.dataset.card).filter(Boolean);
  if(!other.includes(removed)) usedCards.delete(removed);
  renderDeck(usedCards);
  scheduleCalc();
}

/*---------------- MONTE CARLO ----------------*/
function getPlaced(){
  const hero = [...document.getElementById("hero").children].map(x=>x.dataset.card).filter(Boolean);
  const flop = [...document.getElementById("flop").children].map(x=>x.dataset.card).filter(Boolean);
  const turn = [...document.getElementById("turn").children].map(x=>x.dataset.card).filter(Boolean);
  const river = [...document.getElementById("river").children].map(x=>x.dataset.card).filter(Boolean);
  const board = [...flop,...turn,...river];
  const villain = [...document.getElementById("villain").children].map(x=>x.dataset.card).filter(Boolean);
  return {hero,board,villain};
}

function rankToVal(r){ return R.indexOf(r); }

function eval5cards(cardStrs){
  const ranks = cardStrs.map(c=>rankToVal(c[0]));
  const suits = cardStrs.map(c=>c[1]);
  const cnt = Array(13).fill(0); for(let r of ranks) cnt[r]++;
  const freq={}; for(let i=0;i<13;i++){ if(cnt[i]>0){ freq[cnt[i]] = freq[cnt[i]] || []; freq[cnt[i]].push(i); } }
  const suitCounts = {}; for(let s of suits) suitCounts[s]=(suitCounts[s]||0)+1;
  const isFlush = Object.values(suitCounts).some(v=>v===5);
  let uniq=[]; for(let i=12;i>=0;i--) if(cnt[i]) uniq.push(i);
  let isStraight=false, topStraight=-1;
  if(uniq.length>=5){
    const ext = uniq.slice(); if(uniq[0]===12) ext.push(-1);
    for(let i=0;i<ext.length;i++){
      let consec=1;
      for(let j=i+1;j<ext.length;j++){ if(ext[j]===ext[j-1]-1) consec++; else break; if(consec>=5){ isStraight=true; topStraight=ext[j-4]; break; } }
      if(isStraight) break;
    }
    if(!isStraight){ const need=[12,3,2,1,0]; if(need.every(x=>cnt[x]>0)){ isStraight=true; topStraight=3; } }
  }
  if(isFlush){
    let flushSuit=null; for(let s in suitCounts) if(suitCounts[s]===5) flushSuit=s;
    const suitRanks = cardStrs.filter(c=>c[1]===flushSuit).map(c=>rankToVal(c[0])).sort((a,b)=>b-a);
    if(suitRanks.length>=5) return [5,...suitRanks.slice(0,5)];
  }
  if(freq[4]) return [7,freq[4][0],...getKickers(cnt,[freq[4][0]])];
  if(freq[3] && (freq[2] || freq[3].length>1)){ const trips=freq[3].slice().sort((a,b)=>b-a); const pair=(freq[2]?freq[2].slice().sort((a,b)=>b-a)[0]:-1) ?? (trips.length>1?trips[1]:-1); return [6,trips[0],pair]; }
  if(isStraight) return [4,topStraight];
  if(freq[3]) return [3,freq[3][0],...getKickers(cnt,[freq[3][0]])];
  if(freq[2] && freq[2].length>=2){ const pairs=freq[2].slice().sort((a,b)=>b-a); const kicker=getKickers(cnt,[pairs[0],pairs[1]])[0]; return [2,pairs[0],pairs[1],kicker]; }
  if(freq[2]) return [1,freq[2][0],...getKickers(cnt,[freq[2][0]])];
  const top=[]; for(let i=12;i>=0;i--) if(cnt[i]) top.push(i);
  return [0,...top.slice(0,5)];
}

function getKickers(cnt, exclude){ const arr=[]; for(let i=12;i>=0;i--){ if(exclude.includes(i)) continue; for(let t=0;t<cnt[i];t++) arr.push(i); if(arr.length>=5) break; } return arr.slice(0,5); }
function compareHands(a,b){ for(let i=0;i<Math.max(a.length,b.length);i++){ const ai=(i<a.length)?a[i]:0; const bi=(i<b.length)?b[i]:0; if(ai>bi) return 1; if(ai<bi) return -1; } return 0; }
function eval7cards(cardStrs){ let best=null; for(let i=0;i<7;i++){ for(let j=i+1;j<7;j++){ const five=[]; for(let k=0;k<7;k++) if(k!==i && k!==j) five.push(cardStrs[k]); const v=eval5cards(five); if(!best || compareHands(v,best)>0) best=v; } } return best; }

let calcTimeout=null;
function scheduleCalc(){ if(calcTimeout) clearTimeout(calcTimeout); calcTimeout=setTimeout(()=>{ calcTimeout=null; autoCalc(); },100); }

function autoCalc() {
  const placed = getPlaced();
  const hero = placed.hero;
  const output = document.getElementById("output");
  const sub = document.getElementById("subOutput");

  if(hero.length<2){ output.textContent="Equity: —"; sub.textContent="Inserisci le 2 carte del giocatore (Hero) per calcolare."; return; }

  const totalPlayers = parseInt(document.getElementById("players").value,10);
  const trials = parseInt(document.getElementById("trials").value,10);

  let rem = [];
  for(let s of SUITS) for(let r of R) rem.push(r+s);
  const placedAll = [...hero,...placed.board,...placed.villain];
  rem = rem.filter(x => !placedAll.includes(x));

  let wins=0, ties=0;
  for(let t=0;t<trials;t++){
    let d = rem.slice();
    for(let i=d.length-1;i>0;i--){ let j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }

    let simBoard = [...placed.board];
    const toDrawBoard = 5 - simBoard.length;
    for(let i=0;i<toDrawBoard;i++) simBoard.push(d.pop());

    let simVillain = [];
    if(placed.villain.length===2) simVillain.push([...placed.villain]);
    const neededVillains = totalPlayers - 1 - simVillain.length;
    for(let i=0;i<neededVillains;i++) simVillain.push([d.pop(),d.pop()]);

    const heroVal = eval7cards([...hero,...simBoard]);
    let win=true, tie=false;
    for(let i=0;i<simVillain.length;i++){
      const v = eval7cards([...simVillain[i],...simBoard]);
      const cmp = compareHands(heroVal,v);
      if(cmp<0){ win=false; break; }
      if(cmp===0) tie=true;
    }
    if(win) wins++; else if(tie) ties++;
  }

  const eq = (wins+ties*0.5)/trials*100;
  output.textContent=`Equity: ${eq.toFixed(1)}%`;
  sub.textContent=`Simulazione Monte Carlo (${trials} trials)`;
}

/*---------------- INIT ----------------*/
document.getElementById("trials").oninput=function(){ document.getElementById("trialsLabel").textContent=this.value; scheduleCalc(); }
document.getElementById("reset").onclick=function(){ localStorage.clear(); usedCards.clear(); initFields(); buildOrderedDeck(); renderDeck(); scheduleCalc(); }
document.getElementById("export").onclick=function(){ alert("Funzione esporta piattaforma non implementata demo."); }

buildOrderedDeck();
initFields();
renderDeck();
</script>
</body>
</html>
